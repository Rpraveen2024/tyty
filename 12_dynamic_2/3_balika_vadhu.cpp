/*
Anandi and Jagya were getting married again when they have achieved proper age. Dadi Sa invited Alok Nath to do the kanyadaan and give blessings. Alok Nath has 2 blessings. Each bessing is in the form of a string consisting of lowercase charaters(a-z) only. But he can give only one blessing of K length because some priest told him to do so. Thus he decides to generate a blessing using the other two blessings. While doing this he wants to ensure that happiness brought into their life by his blessing is maximum.
The generated blessing is a common subsequence of length K of the two blessings he has. Happiness of the blessing he generates is calculated by the sum of ASCII values of characters in the blessing and he wants the happiness to be maximum. If he is not able to generate a common subsequence of length K then the happiness is 0 (zero). Alok Nath comes to you and asks you to find the maximum happiness that can be generated by the two blessings he has.
Input Specification
First line consists of number of test cases t. Each test case consists of two strings b1 (blessing 1),b2 (blessing 2) and an integer K, each of them in separate lines.
Output Specification
Output consists of t lines each containing an integer denoting the maximum happiness value that can be generated by the two blessings.
Constraint
1 <= t <= 50

1 <= length(b1) , length(b2) <= 100 

1 <= K <= 100
Sample Input
2
asdf
asdf
3
anandi
jagya
3
Sample Output
317
0
*/

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll soln_rec(string s1,string s2,int k, int***storage){
    int n=s1.length();
    int m=s2.length();
    
    // base cases
    if(k==0){
        return 0;
    }
    // if k!=0, and 1 string is empty already then ATQ ans should be 0
    // so we return INT_MIN ans will check it in main
    if(n==0||m==0){
        return INT_MIN;
    }
    // work already done
    if(storage[n][m][k]!=-1){
        return storage[n][m][k];
    }
    // 1st not same
    if(s1[0]!=s2[0]){
        // possiblity 1 - s1's first not included
        ll poss1=soln_rec(s1.substr(1),s2,k,storage);
        // possiblity 1 - s1's first not included
        ll poss2=soln_rec(s1,s2.substr(1),k,storage);
        ll ans=max(poss1,poss2);
        storage[n][m][k]=ans;
        return ans;
    }
    // 1st same
    // possibility 1 - num is included, so add the ascii to result - no i need k-1 more results
    ll poss1=s1[0]+soln_rec(s1.substr(1),s2.substr(1),k-1,storage);
    // possibility 2 - num is not included, s1's first not included
    ll poss2=soln_rec(s1.substr(1),s2,k,storage);
    // possibility 1 - num is not included, s2's first not included
    ll poss3=soln_rec(s1,s2.substr(1),k,storage);
    ll ans=max(poss1,max(poss2,poss3));
    storage[n][m][k]=ans;
    return ans;
}

int main()
{
    int t;
    cin>>t;
    while(t--){
        
        string s1,s2;
        int k;
        cin>>s1>>s2>>k;
        
        int ***storage=new int**[s1.length()+1];
        for(int i=0;i<=s1.length();i++){
            storage[i]=new int*[s2.length()+1];
            for(int j=0;j<=s2.length();j++){
                storage[i][j]=new int[k+1];
            }
        }
        for(int i=0;i<=s1.length();i++){
            for(int j=0;j<=s2.length();j++){
                for(int x=0;x<=k;x++){
                    storage[i][j][x]=-1;
                }
            }
        }

        ll ans=soln_rec(s1,s2,k,storage);

        for(int i=0;i<=s1.length();i++){
            for(int j=0;j<=s2.length();j++){
                delete storage[i][j];
            }
            delete storage[i];
        }
        delete storage;
        
		if(ans<0){
            cout<<0<<endl;
        }else{
            cout<<ans<<endl;
        }

    }
    return 0;
}



// my initial soln - working only for some test cases due to recursion

// ll lcs(string s1,string s2,int **storage,string &lcs_s){
//     // base cases
//     if(s1.length()==0||s2.length()==0){
//         return 0;
//     }
//     // work already done
//     if(storage[s1.length()][s2.length()]>=0){
//         return storage[s1.length()][s2.length()];
//     }
//     // 1st equal
//     if(s1[0]==s2[0]){
//         lcs_s.push_back(s1[0]);
//         ll ans=1+lcs(s1.substr(1),s2.substr(1),storage,lcs_s);
//         storage[s1.length()][s2.length()]=ans;
//         return ans;
//     }
//     // 1st not equal
//     ll ans=max( lcs(s1.substr(1),s2,storage,lcs_s) , lcs(s1,s2.substr(1),storage,lcs_s) );
//     storage[s1.length()][s2.length()]=ans;
//     return ans;
// }

// int main()
// {
//     int t;
//     cin>>t;
//     while(t--){
        
//         string s1,s2;
//         int k;
//         cin>>s1>>s2>>k;
        
//         int **storage=new int*[s1.length()+1];
//         for(int i=0;i<=s1.length();i++){
//             storage[i]=new int[s2.length()+1];
//         }
//         for(int i=0;i<=s1.length();i++){
//             for(int j=0;j<=s2.length();j++){
//                 storage[i][j]=-1;
//             }
//         }

//         // this will save the lcs
//         string lcs_s;

//         ll lcs_l=lcs(s1,s2,storage,lcs_s);
        
//         // cout<<lcs_s<<endl;
        
//         if(lcs_l<k){
//             cout<<0<<endl;
//         }else{
			
//             sort(lcs_s.begin(),lcs_s.end());
//             ll ans=0;
//             for(int i=0;i<k;i++){
//                 ans+=lcs_s[(lcs_s.length()-1)-i];
//             }

//             cout<<ans<<endl;
//         }

//         for(int i=0;i<=s1.length();i++){
//             delete storage[i];
//         }
//         delete storage;

//     }
//     return 0;
// }
